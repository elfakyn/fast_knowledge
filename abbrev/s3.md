# Bucket policy example

```json
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Principal": {
                "AWS": "arn:aws:iam::AccountB:user/AccountBUserName"
            },
            "Action": [
                "s3:GetObject",
                "s3:PutObject",
                "s3:PutObjectAcl"
            ],
            "Resource": [
                "arn:aws:s3:::AccountABucketName/*"
            ]
        }
    ]
}
```

# So what's the problem?

## Incident response: deleting user.

Before:

```json
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Principal": {
                "AWS": "arn:aws:iam::123456789012:user/Test"
            },
            "Action": [
                "s3:ListBucket",
                "s3:GetBucketLocation"
            ],
            "Resource": "arn:aws:s3:::TestyMcTestFace"
        }
    ]
}
```

After:

```json
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Principal": {
                "AWS": "AIDAxxxxxxxxxxxxxxxxx"
            },
            "Action": [
                "s3:ListBucket",
                "s3:GetBucketLocation"
            ],
            "Resource": "arn:aws:s3:::elfakyn-testytest"
        }
    ]
}
```


# You must create the user first

This one is pretty self-explanatory. If a principal does not exist when you create the policy, it will return an Invalid Principal error. That means that, if you grant access to a third party via a bucket policy, you'll have to coordinate such that the principal is created first.

### Certain bucket policies will result in a cryptic 500 error

If a bucket policy is invalid in such a way that it breaks the internal validator, it will return a 500 error instead of anything useful. Here's one such example: 

```json
{
    "Version": "2012-10-17",
    "Id": "whatever",
    "Statement": [
        {
            "Sid": "ReadOnly",
            "Effect": "Allow",
            "Principal": {
                "AWS": []
            },
            "Action": "s3:GetObject",
            "Resource": "arn:aws:s3:::my-bucket/*"
        }
    ]
}
```

[Read more here.](./s3_bucket_policy_500_errors.md)

If you have any automation that handles bucket policies, you need to be able to handle such errors.

## Workaround by using condition keys

You can choose to instead use [a PrincipalArn inside a Condition Key](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_condition-keys.html#condition-keys-principalarn). These do not get converted internally, so will remain valid even if the principal is deleted and recreated. This means, however, that the above David scenario may happen. If the principal is deleted and a new principal with the same ARN is created, you might not actually want access to persist. It depends on your use case.

## Security Implications

### Brute-forcing valid principal names is possible

You can use this mechanism to brute force valid AWS accounts as well as valid principals within an AWS account (such as user names). To do this, simply attempt to apply a bucket policy. If the principal is valid, it will apply successfully. If the principal doesn't exist, it will fail. AWS knows about this issue and it is intended behavior, so don't go submitting a bug report on this one; I already did, and they WontFix.

Principal names may reveal potentially sensitive information such as:

* Who works for your company
* What clients you do business with
* What technologies you use
* If you do anything sketchy security-wise (such as all-powerful machine users)
* Potential vulnerabilities

### User compromise will break cross-account access

If the credentials for an AWS user are compromised, AWS will automatically quarantine the user (they monitor places like GitHub for leaks) and the AWS Abuse Team will ABSOLUTELY INSIST that you delete the user and create a new one (in the strongest possible terms: "You're in violation of our TOS, you must absolutely delete this user, you have no choice").

You are allowed to create a new user with the same name and ARN, but cross-account access will still break. If this cross-account access involves third parties, you're in for an awkward conversation...

### Explicit denies will stop working if the principal is deleted and recreated

If you rely on explicit denies on a bucket policy to deny access to specific principals (such as users or roles), those explicit denies will stop working if the principals are deleted and recreated, since they refer to the old Principal ID.

### Canonical IDs offer no extra security

AWS advertises Canonical IDs (`1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef`) as obfuscated versions of an AWS account ARN (`arn:aws:iam::123456789012:root`). If you want to give a third party your account ARN (for instance, so they can create a cross-account bucket policy granting it access), but don't want to divulge your account number, you can give them the Canonical ID, or so the story goes.

But this doesn't actually work. All you have to do is save the Canonical ID in a bucket policy, and next time you view the policy, [AWS will helpfully convert it back into an account ARN with an account number.](https://docs.amazonaws.cn/en_us/AmazonS3/latest/dev/s3-bucket-user-policy-specifying-principal-intro.html) Nifty!

## Conclusion

AWS works in arcane ways. It is almost certain that you will find every idiosyncracy of the system documented somewhere, but it is just as certain that it *will not be in the first place you're looking*. You may find confusing and contradictory documentation.

If you're about to make a mission-critical change, open an AWS support ticket and get the correct team, in this case, s3, to explicitly tell you what will happen (they might still be wrong!). Because whatever happens, it will be a surprise to everyone.
